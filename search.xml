<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[运输层协议概述]]></title>
    <url>%2Fhelio%2F2019%2F06%2F28%2FNetWorking01%2F</url>
    <content type="text"><![CDATA[你如何收到好友的QQ消息?&emsp;&emsp;你有没有想过这个问题，当你和朋友使用QQ进行聊天的时候，你的消息是如何发送到好友的手机或者电脑上去的呢？&emsp;&emsp;在解决这个问题之前不妨先思考一下另一个问题。有一天远方的朋友给你写了一封信，快递员收到信件之后要把信件送到你的手中。首先他要做的是根据信件上的地址信息找到你家所在的那一栋楼，找到你家所在的那一栋楼之后，快递员会再根据你家的门牌号才能把信件送到你的手中。&emsp;&emsp;同理，QQ上的消息要从好友哪里发送到你这里。第一步是要做的是要找到你的手机或者电脑在网络中的地址(IP地址)，找到你的设备在网络中的地址之后，你的设备中同时开启了许多其他的网络应用，消息仍然不知道发送到你的手机的哪个位置，为了把信息准确的送到QQ上而不是其他的应用上，必须使用端口号来区别设备上各种不同的网络的应用，至此消息就可以从好友QQ上准确的发送到你的QQ上了。 什么是网络协议？&emsp;&emsp;首先让我们看一段解释: 一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他事件所采取的动作。 &emsp;&emsp;咋看这个解释，可能是一头雾水。我们通过一个类比来解释一下。假如你忘记带手表了，这时你想向一个陌生人询问现在的时间，首先你要的做的是和陌生人打招呼(发送报文)。如果陌生人回应了你(接收一条报文后采取的动作)，你才能继续向她问时间。如果陌生人不会说中文，那么你们就不能进行后继的交流了。这是一个简单的人类之间进行交流的协议。&emsp;&emsp;同理在计算机网络中，两个进行通信的设备也应该遵循相同的网络通信协议才能进行通信。 因特网运输层概述&emsp;&emsp;运输层位于网络层之上应用层之下，该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用。如果不同主机之间的应用进程要进行直接通信的话，唯一的方法是使用应用层的协议。&emsp;&emsp;运输层上使用的协议主要有两种：UDP、TCP。下表展示处了两种协议分别会在什么应用中会被使用到。可以看出TCP协议通常被使用到对数据丢失不能忍受的应用上，如电子邮件、即时通信，因为TCP协议在传输数据的过程中不会造成数据的丢失。而UDP协议在传输的过程中会有些许的数据丢失，所以它通常会被应用到语音电话、视频电话等对数据丢失可以忍受的应用上。 应用 应用层协议 下面的运输协议 电子邮件 SMTP TCP 远程终端访问 Telnet TCP Web HTTP TCP 文件运输 FTP TCP 远程文件服务器 NFS 通常UDP 流式多媒体 通常专用2 UDP或TCP 因特网电话 通常专用 UDP或TCP 面向连接的运输：TCP&emsp;&emsp;TCP之所以是被称为面向连接的,是因为两台主机上下应用进程在进行通信之前，必须先“握手”即它们必须相互发送某些预备报文段，以建立连接，这是保证TCP协议用来传输数据可靠的手段之一。 三次握手&emsp;&emsp;前面谈到，TCP协议在进行通信之前会进行三次握手，三次握手之后，两台主机上的应用进程之间才会建立连接，那么三次握手是如何进行的呢？&emsp;&emsp;第一步：客户端的TCP首先向服务器的TCP发送一个特殊的SYN报文段(该报文段中不包括应用层数据),报文首部的标识位SYN会被置为1，同时报文中会加上客户端随机生成的一个初始序号(client_isn),将此编号放置于该起始的TCP SYN报文段的序号字段中。最后该报文段会被封装在一个IP数据报中，发送给服务器。&emsp;&emsp;第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会向客户端发送允许连接报文(SYNACK报文段)，该报文首部的标识位SYN会被置为0，同时报文中会加上服务器选择的初始序号(server_isn),将此编号放置到TCP报文段首部的序号字段中，同时TCP报文段的确认号字段被置为client_isn + 1。&emsp;&emsp;第三步：在收到SYNACK报文段后，客户端也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段就像了确认(该客户通过将值server_isn + 1放置到TCP报文段首部的确认段中来完成此项工作)。因为连接邮件建立了，所以该SYN比特被置为0。&emsp;&emsp;一旦这三个步骤顺利完成，客户端和服务器之间就可以相互通信了。 无连接运输：UDP&emsp;&emsp;顾名思义，UDP在应用进程间传输数据之前不需要像TCP那么麻烦的要与服务器进行三次握手，采用UDP时，只要应用进程将数据传输给UDP，UDP就会将此数据打包进报文段并立即将其传递给网络层，发送给远程主机。所以它就无法保证数据是否会被准确的交付到远程主机应用进程。 UDP和TCP比较&emsp;&emsp;UDP传输数据时不需要建立连接，但会丢失数据。TCP传输数据可靠。两个协议的不同特点导致他们使用的场合不同，在实际的开发中需要视工程的要求来决定使用哪一个协议。 - UDP TCP 是否需要与远程主机建立连接 否 是 报文首部开销 8byte 20byte 数据传输可靠性 不可靠 可靠]]></content>
      <categories>
        <category>05 网络编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程学习（二）]]></title>
    <url>%2Fhelio%2F2019%2F06%2F23%2FThread02%2F</url>
    <content type="text"><![CDATA[向线程传递参数&emsp;代码中实现了三种不同的方法向线程中传递参数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/*----------------------------------------------------------------------- written by helio, 2019 ThreadSample3-----------------------------------------------------------------------*/using System;using System.Threading;namespace ThreadSample&#123; class Program &#123; static void Main(string[] args) &#123; var sample = new ThreadSample(10); var ThreadOne = new Thread(sample.CountNumbers); ThreadOne.Name = "ThreadOne"; ThreadOne.Start(); ThreadOne.Join(); Console.WriteLine("------------------------"); var ThreadTwo = new Thread(Count); ThreadTwo.Name = "ThreadTwo"; ThreadTwo.Start(8); ThreadTwo.Join(); Console.WriteLine("------------------------"); var ThreadThree = new Thread(() =&gt; CountNumbers(12)); ThreadThree.Name = "ThreadThree"; ThreadThree.Start(); ThreadThree.Join(); Console.WriteLine("------------------------"); int i = 10; var ThreadFour = new Thread(() =&gt; PrintNumber(i)); i = 20; var ThreadFive = new Thread(() =&gt; PrintNumber(i)); ThreadFour.Start(); ThreadFive.Start(); Console.ReadKey(); &#125; static void Count(object iterations) &#123; CountNumbers((int)iterations); &#125; static void CountNumbers(int iterations) &#123; for (int i = 1; i &lt;= iterations; i++) &#123; Thread.Sleep(TimeSpan.FromMilliseconds(0.5)); Console.WriteLine("&#123;0&#125; prins &#123;1&#125;", Thread.CurrentThread.Name, i); &#125; &#125; static void PrintNumber(int number) &#123; Console.WriteLine(number); &#125; class ThreadSample &#123; private readonly int m_iterations; public ThreadSample(int iterations) &#123; m_iterations = iterations; &#125; public void CountNumbers() &#123; for (int i = 1; i &lt;= m_iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine("&#123;0&#125; prints &#123;1&#125;", Thread.CurrentThread.Name, i); &#125; &#125; &#125; &#125;&#125; 工作原理方法一：&emsp;当主程序启动时，首先创建了ThreadSample类的一个对象，并提供了一个迭代次数。然后使用该对象的CounetNumbers方法启动线程。该方法运行在另一个线程中，但是使用数字10，该数字是通过ThreadSample对象的构造函数传入的。 方法二：&emsp;另一种传递数据的方式是使用Thread.Staru方法。该方法会节后一个对象，并将该对象传递给线程。为了应用该方法，在线程启动的方法必须接收object类型的单个参数。 方法三：&emsp;接下来的方式是使用lambda表达式。这可能会导致几个问题。例如，如果在多个lanbda表达式中使用相同的变量，他们会共享该变量。当启动ThreadFour和ThreadFive线程时，他们都会打印20，因为在这两个线程启动之前变量被修改为20。 线程锁为什么要用线程锁？&emsp;&emsp;所谓同步，是指多个线程之间存在先后执行的顺序的关联关系。如果一个线程必须在两一个线程完成某个工作后才能继续执行，则必须考虑如何让让其保持同步，以确保在系统上同时运行多个线程而不会出现死锁或逻辑错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*----------------------------------------------------------------------- written by helio, 2019 ThreadSample4-----------------------------------------------------------------------*/using System;using System.Threading;namespace LockSample1&#123; class Program &#123; static void Main(string[] args) &#123; Thread[] threads = new Thread[10]; Account acc = new Account(1000); for (int i = 0; i &lt; 10;i++) &#123; Thread t = new Thread(acc.AutoWithdraw); t.Name = "Thread" + i; threads[i] = t; &#125; for (int i = 0; i &lt; 10; i++) threads[i].Start(); Console.ReadKey(); &#125; class Account &#123; private Object lockedObj = new object(); private int m_balenace; Random r = new Random(); public Account(int initial) &#123; m_balenace = initial; &#125; public int Withdraw(int amount) &#123; Thread.Sleep(TimeSpan.FromMilliseconds(100)); if (m_balenace &lt; 0) &#123; Console.WriteLine("余额不足！"); &#125; lock (lockedObj) &#123; if (m_balenace &gt;= amount) &#123; Console.Write("&#123;0&#125;取款---取款前余额：&#123;1&#125; 取款 &#123;2&#125; ", Thread.CurrentThread.Name, m_balenace, amount); m_balenace -= amount; Console.WriteLine("取款后余额：&#123;0&#125;", m_balenace); return amount; &#125; else &#123; return 0; &#125; &#125; &#125; public void AutoWithdraw() &#123; for (int i = 0; i &lt; 100; i++) &#123; Withdraw(r.Next(1, 100)); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>04 C#基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程学习（一）]]></title>
    <url>%2Fhelio%2F2019%2F06%2F23%2FThread01%2F</url>
    <content type="text"><![CDATA[什么是进程和线程？&emsp;&emsp;在进行多线程学习之前，我们首先要搞懂线程和进程这两个概念。 进程: 当你浏览网页的时候可以边听着歌，同时你的QQ也打开了。此时，在你的Windows上运行的所有应用程序(QQ、QQ音乐、火狐浏览器)都可以被成为一个进程。 线程: 当你使用火狐浏览器阅读一个网页的时候，浏览器也同时可以在下载文件，此时浏览器为了让你在下载文件的同时可以你浏览网页，会开启两个线程来处理这种情况：一个线程用来浏览网页，另一个线程用来下载文件，这两个线程会各自做自己的事情互不干扰。 &emsp;&emsp;当系统创建一个进程的时候，会自动为进程创建一个线程，这个线程被成为应用进程的主线程。然后这个主线程会再创建更多的线程。 多线程原理: 对于所有要运行的线程，操作系统会轮流为每个线程分配一些CPU时间。它会采取循环的方式，为每个线程都分配时间片，从而营造出所有线程并行的”假象”。 创建线程&emsp;&emsp;在开始线程编程之前先看几个线程相关的函数。 Thread thread = new Thread(ParameterizedThreadStart start); &emsp;&emsp;为了开启一个新的线程，首先要初始化Thread类的新实例 thread, 参数start表示开始执行线程时要调用的方法委托。也就是说线程开始后会跳转到 start 函数内部运行。 thread.Start(); &emsp;&emsp;之后可以使用Thread类的方法Start()方法启动线程。 &emsp;&emsp;为了模拟使用浏览器阅读一个网页的时候，同时也可以下载文件。我们在程序中使用了两个线程：一个主线程和一个thread_donwnload线程，主线程会不断递增并打印阅读的进度，而thread_download线程会不断递增并打印下载的进度。程序具体程序如下 :1234567891011121314151617181920212223242526272829303132333435363738394041424344/*------------------------------------------------------- written by helio, 2019 ThreadSample1 - 使用线程模拟边浏览网页边下载-------------------------------------------------------*/using System;using System.Threading;namespace ThreadSample01&#123; class Program &#123; /// &lt;summary&gt; /// 开启一个用来模拟下载的线程 /// &lt;/summary&gt; private static void Download() &#123; Console.WriteLine("Download Start."); for (int i = 0; i &lt;= 100; i++) Console.WriteLine("Downloading &#123;0&#125;%", i); Console.WriteLine("Download finished!"); &#125; /// &lt;summary&gt; /// 主线程模拟阅读浏览器 /// &lt;/summary&gt; private static void Read() &#123; Console.WriteLine("Read Start."); for (int i = 0; i &lt;= 100; i++) Console.WriteLine("Reading &#123;0&#125;%", i); Console.WriteLine("Reading finished!"); &#125; static void Main(string[] args) &#123; Thread thread_download = new Thread(Download); thread_download.Start(); Read(); Console.ReadKey(); &#125; &#125;&#125; &emsp;&emsp;从程序运行结果可以观察到阅读进度和下载进度是在交替增加的，可以看出主线程和thread_download线程是在一种并行的状态，此时可以说我们成功的模拟了边浏览网页边下载。 其他线程相关函数&emsp;&emsp;创建线程只是最基本的线程操作函数，如下表格列出了另外几个比较常用的线程操作函数。 名称 说明 Sleep方法 将当前线程挂起指定的时间 Join方法 将指定的线程合并到当前线程中，并阻止当前线程，直至指定的线程结束或者经过了指定时间。 Abort方法 在调用此方法的线程上引发 System.Threading.ThreadAbortException，以开始终止此线程的过程,调用此方法通常会终止线程。 &emsp;&emsp;现有三个要完成的任务Main、TaskOne、TaskTwo。要求如下: 第一个任务要和第二个任务同时执行. 第三个任务必须等到第二个任务开始后才能执行。 第二个任务必须等待第三个任务完成后才能继续其任务。 第三个任务需要执行到一半的时候终止。 &emsp;&emsp;为了实现上诉需求，我们首先要做的是在Main函数的主线程中开启一个线程用来执行TaskOne,之后在TaskOne线程中开启一个线程用来执行TaskTwo。&emsp;&emsp;启动TaskTwo线程后，为了满足第三个条件，可以使用Join方法，使得TaskOne线程必须等待TakskTow线程执行完成轴才能继续执行;&emsp;&emsp;为了使得TaskTwo执行到一半时终止，我们可以在TaskTwo所在的线程中使用Abort方法，强制终止线程。至此，上诉四个需求都可得到满足，具体实现见如下代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*------------------------------------------------------- written by helio, 2019 ThreadSample2.cs - 完成三个任务---------------------------------------------------------*/using System;using System.Threading;namespace ThreadSample02&#123; class Program &#123; private static void TaskOne() &#123; Console.WriteLine("TackOne Start..."); Thread thread_tacktwo = new Thread(TaskTwo); thread_tacktwo.Start(); // 必须等待tasktwo 执行完才能继续执行taskone thread_tacktwo.Join(); Console.WriteLine("TaskTwo Finished..."); &#125; private static void TaskTwo() &#123; Console.WriteLine("TaskTwo Start."); for (int i = 0; i &lt;= 20; i++) &#123; Console.WriteLine("TaskTwo &#123;0&#125;%", i * 5); // TaskTwo执行到一本时被强制终止 if (i == 5) &#123; Console.WriteLine("TaskTwo Abort!"); Thread.CurrentThread.Abort(); break; &#125; &#125; &#125; private static void Read() &#123; Console.WriteLine("Read Start."); for (int i = 0; i &lt;= 20; i++) Console.WriteLine("Reading &#123;0&#125;%", i * 5); Console.WriteLine("Reading finished!"); &#125; static void Main(string[] args) &#123; Thread thread_tackone = new Thread(TaskOne); thread_tackone.Start(); Read(); Console.ReadKey(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>04 C#基础</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeMCU学习(四):与其他设备通信]]></title>
    <url>%2Fhelio%2F2019%2F04%2F04%2FNodeMCU04%2F</url>
    <content type="text"><![CDATA[TCP连接&nbsp;&nbsp;TCP是计算机网络中运输层协议，是应用层协议http协议的支撑协议。两台远程主机之间可以通过TCP协议进行通信并交换信息，前提是，相互通信的两台主机之间知道彼此的IP地址和端口号。 NodeMCU作为TCP客户端实现局域网内点亮Led灯（通过路由器中转）&nbsp;&nbsp;NodeMCU可以被配置为一个TCP客户端，同时将一台网络设备（如电脑）配置为TCP服务器端，将NodeMCU连接到已经配置好的TCP服务器端上后，两者即可进行通信。&nbsp;&nbsp;通信方法有两种，方法一是将NodeMCU设置为Soft AP模式，让电脑之间连接到它的WiFi上之后再与它进行通信。方法二是将NodeMCU和电脑同时连接到一个WiFi上，这样做的好处是与NodeMCU通信的设备数量不会受到较大的限制，因为将NodeMCU设置为SoftAP模式时，最大可以连接到其上的设备数为8个。&nbsp;&nbsp;首先使用方法二使两者连接到一起并进行通信，打开网络调试助手，将其协议类型设置为TCP Server(如图4-1)，更改本地端口号为任意值，在本次实验中被设置为1234。记住TCP Server的IP地址和端口号之后，将其打开(连接)。将程序中的IP地址和端口号换成上面设置好的值，并把NodeMCU的D0端口连接上一个Led，将程序烧录到Node MCU中。完成之后在网络调试助手中发送“0”或者“1”就会改变Led的状态。NodeMCU程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*----------------------------------------------------------- written by helio, 2019WiFiLed.ino - NodeMCU连接到路由器WiFi，将其配置为TCP客户端同时与连接到路由器上的Tcp服务器设备（手机或电脑）建立Tcp连接------------------------------------------------------------*/const int Led = 16;const char *RemoteIp = "192.168.1.105"; // 设置远程主机Ip地址const int RemotePort = 1234; // 设置远程主机端口号#include "ESP8266WiFi.h"WiFiClient client; // 创建Tcp客户端void setup()&#123; Serial.begin(115200); Serial.println(); WiFi.begin("CEET305", "office305"); // 设置连接到的WiFi名称和密码 Serial.print("Connecting..."); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print("."); &#125; Serial.println(); Serial.println(WiFi.localIP()); // 打印NodeMCU的IP地址 if (!client.connect(RemoteIp, RemotePort)) // 建立tcp连接 &#123; Serial.println("Connected failed!"); return; &#125; pinMode(Led, OUTPUT); // 设置GPIO16为输出模式 digitalWrite(Led, LOW); // 初始时，GPIO16输出低电平 &#125;void loop()&#123; if (client.available()) &#123; char ch = client.read(); // 读取远程网络串口发来的数据 if (ch == '0') digitalWrite(Led, LOW); else if (ch == '1') digitalWrite(Led, HIGH); &#125;&#125; WiFiLed.ino函数解析&nbsp;&nbsp;实例化一个 WiFiClient 对象，对象名称为client。WiFiClient类是在esp8266库中已经封装好的一个TCP客户端，使用它可以实现TCP客户端的实例化，与TCP服务器的连接、通信、状态判断等功能。随后，通过WiFiClient类的一个成员函数 connect() 设置需要连接的服务器的 IP地址和端口号，并与远程TCP服务器建立连接，通过其返回值判断是否连接成功。连接成功后，即可与服务器进行通信，通过类的成员函数 isavailable() 函数判断是否有消息从服务器端发送过来，并根据消息的内容对NodeMCU上GPIO16口的Led灯进行控制。 NodeMCU作为TCP服务器端实现局域网内点亮Led灯（不使用路由器）&nbsp;&nbsp;第二种方法是将NodeMCU设置为softAP模式，相当于一种热点模式，设置好其WiFi的名字和密码之后，电脑（TCP客户端）即可通过WiFi连接到其上并与之进行通信。 &nbsp;&nbsp;首先把Led灯连接到NodeMCU的GPIO16口，之后将程序烧录至NodeMCU中之后，在串口监视器中可以看到设置成softAP模式成功（如图4-2），同时可以获知NodeMCU的IP地址。同时在电脑的WiFi管理中心中也可以看到刚刚设置的WiFi，将电脑连接到此WiFi。 &nbsp;&nbsp;之后，在网络调试助手中（如图4-3），将协议类型设置为TCP Client，同时将IP地址设置为刚刚在串口监视器中得到的IP地址，端口设置为在程序中已经设置好的端口好。完成以上步骤之后，连接到TCP Server，连接上之后马上就会收到来自TCP Server发送来的消息“Hello from NodeMCU”，在TCP Client中发送”0”或者”1”即可控制Server端-NodeMCU上的Led灯。 NodeMCU程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*------------------------------------------------------------ written by helio, 2019SoftApLed.ino - 将NodeMCU设置为soft-AP模式（热点模式）其他设备可以连接到该热点,并将NodeMCU设置为Tcp服务器端，同时将其他设备（手机，电脑）配置为Tcp客户端，并连接到NodeMCU服务器上，向其发送控制消息------------------------------------------------------------*/#include &lt;ESP8266WiFi.h&gt;const int Led = 16; // 将Led连接到GPIO16端口const int LocalPort = 8266; // 设置ModeMCU端口WiFiServer server(LocalPort);void setup()&#123; Serial.begin(115200); Serial.println(); Serial.print("Setting soft_AP..."); if (WiFi.softAP("ESP8266", NULL)) Serial.print("Ready"); else Serial.print("Failed"); Serial.println(); server.begin(); Serial.printf("TcpServerstarted,%s", WiFi.softAPIP().toString().c_str()); pinMode(Led, OUTPUT); digitalWrite(Led, LOW);&#125;void loop()&#123; WiFiClient client = server.available(); // 等待客户端连接 if (client) &#123; client.write("Hello from NodeMCU"); Serial.println("Client connected"); while (client.connected()) // 当客户端保持连接时，从客户端读取数据 &#123; if (client.available()) // 当客户端发送数据时 &#123; char ch = client.read(); if (ch == '0') digitalWrite(Led, LOW); else if (ch == '1') digitalWrite(Led, HIGH); &#125; &#125; &#125; client.stop(); // 断开连接 &#125; SoftApLed.ino 解析&nbsp;&nbsp;实例化一个WiFi Serve类的对象server,并设置server的端口号，随后将Node MCU使用函数WiFi.softAP()设置为SoftAP模式，同时通过函数WiFi.softAPIP()获得其IP地址并打印到串口上，在loop循环中，通过WiFiServer类的一个成员函数available()等待客户端的连接，当有客户端连接至NodeMCU之后，通过client.write()函数往客户端发送“Hello from Node MCU”字符串并与客户端保持连接，再通过WiFiClient类的一个成员函数available接收从客户端发来的数据并通过其发送来的数据的不同从而控制NodeMCU上的Led灯。]]></content>
      <categories>
        <category>03 Geek</category>
        <category>NodeMCU开发</category>
      </categories>
      <tags>
        <tag>单片机开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeMCU学习(三):进入网络世界]]></title>
    <url>%2Fhelio%2F2019%2F03%2F31%2FNodeMCU03%2F</url>
    <content type="text"><![CDATA[把NodeMCU连接到路由器网络上&nbsp;&nbsp;NodeMCU可以被配置为Station模式和softAP模式或者Station + AP模式，当它被配置为Station模式时，就可以去连接Access Point（如路由器）。当它被配置为Soft Access Point模式时，其他的Station（如手机、电脑）就可以连接到它，并与它进行通信。当它被配置为Station + AP模式时，即可作为Station也可以作为Access Point。&nbsp;&nbsp;使用如下程序配置NodeMCU将其连接到路由器上：12345678910111213141516171819202122232425262728293031323334/*-------------------------------------------------- written by helio, 2019 ConnectToWifi.ino - 串口打印NodeMCU连接到路由器WiFi名称和密码，并打印自身ip地址--------------------------------------------------*/#include &quot;ESP8266WiFi.h&quot;void setup()&#123; Serial.begin(115200); Serial.println(); WiFi.begin(&quot;CEET305&quot;, &quot;office305&quot;); // 设置连接到的WiFi名称和密码 Serial.print(&quot;Connecting...&quot;); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125; Serial.println(); Serial.print(&quot;Connected Succeful to &quot;); Serial.println(WiFi.SSID()); // 打印连接到的WiFi名称 Serial.print(&quot;The Password of this WiFi is:&quot;); Serial.println(WiFi.psk()); // 打印连接到的WiFi的密码 Serial.print(&quot;IP-address is:&quot;); Serial.println(WiFi.localIP()); // 打印NodeMCU的IP地址&#125;void loop()&#123; &#125; ConnectToWifi.ino解析&nbsp;&nbsp;通过函数 WiFi.begin() 设置即将连接的WiFi名称和密码并连接到给定的WiFi。随后根据函数 WiFi.status() 的返回值判断是否连接得到WiFi上，如果此函数的返回值WL_CONNECTED 则说明已经连接到给定WiFi上，否则没有连接上，通过一个循环来等待NodeMCU连接到WiFi上。当连接成功后在串口中通过函数WiFi.SSID()打印连接到的WiFi的名称，通过函数WiFi.psk()打印连接上的WiFi的密码，同时通过函数WiFi.localIP()打印此时NodeMCU的IP地址。&nbsp;&nbsp;程序烧录到NodeMCU中后，打开串口监视器，可以看见NodeMCU成功连接到了设置的网络中。 其他设备连接到NodeMCU上&nbsp;&nbsp;将NodeCMCU设置为SoftAP模式时，其他设备就可以在网络中发现它，并且可以连接到它上面。 123456789101112131415161718192021222324/*------------------------------------------------- written by helio, 2019 SoftAp.ino - 将NodeMCU设置为soft-AP模式（热点模式）其他设备可以连接到该热点-------------------------------------------------*/#include &lt;ESP8266WiFi.h&gt;void setup() &#123; Serial.begin(115200); Serial.println(); Serial.println("Setting soft_AP..."); boolean result = WiFi.softAP("Helio", "Helio1122"); if (result == true) Serial.println("Ready"); else Serial.println("Failed!");&#125;void loop()&#123; Serial.printf("Stations connected = %d\n", WiFi.softAPgetStationNum()); delay(3000);&#125; SoftAP.ino解析&nbsp;&nbsp;通过函数WiFi.softAP()设置将要设置的热点名称和密码，如果将函数的第二个参数值设置为 NULL 时，则其他设备不需要设置密码即可连接该热点，同时，根据函数的返回值判断是否创建成功，同时在串口中打印反馈信息。设置成功后在，可以通过函数WiFI.softAPgetStarion() 获知连接到其上的设备数。&nbsp;&nbsp;将程序烧录到NodeMCU中后，打开电脑或者手机的WiFi管理界面即可发现它设置的网络。 &nbsp;&nbsp;同样打开串口监视器，可以在看到连接到NodeMCU上的设备数量。]]></content>
      <categories>
        <category>03 Geek</category>
        <category>NodeMCU开发</category>
      </categories>
      <tags>
        <tag>单片机开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeMCU学习(二):如何使用NodeMCU进行开发]]></title>
    <url>%2Fhelio%2F2019%2F03%2F31%2FNodeMCU02%2F</url>
    <content type="text"><![CDATA[NodeMCU的GPIO口&nbsp;&nbsp;Arduino的引脚号与NodeMCU的GPIO口直接对应,NodeMCU的GPIO函数pinMode, digitalWrite, DigitalRead也是和Arduino中相同,如果要读取GPIO2引脚的电平，可以使用digitaiRead(2);引脚号0-15可以被用作INPUT,OUTPUT,或者INPUT_PULLUP。Pin16可以被用作INPUT,OUTPUT或INPUT_PULLDOWN_16,初始化时，所有引脚被配置为INPUT。 使用NodeMCU点亮LED灯&nbsp;&nbsp;新建工程，将GPIO16口设置为输出端口，编程实现使得GPIO16口上的Led灯交替闪烁。 12345678910111213141516171819/*----------------------------------------- written by helio, 2019HelloNodeMcu.ino - 使用NodeMCU点亮一个LED灯------------------------------------------*/const int LedPin = 16;void setup()&#123; pinMode(LedPin, OUTPUT); // 将引脚设置为输出&#125;void loop()&#123; digitalWrite(LedPin, HIGH); delay(1000); digitalWrite(LedPin, LOW); delay(1000);&#125;]]></content>
      <categories>
        <category>03 Geek</category>
        <category>NodeMCU开发</category>
      </categories>
      <tags>
        <tag>单片机开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeMCU学习(一):开始之前的准备]]></title>
    <url>%2Fhelio%2F2019%2F03%2F31%2FNodeMCU01%2F</url>
    <content type="text"><![CDATA[安装Aduino开发环境&nbsp;&nbsp;在官网中下载Arduino开发环境，或者在网盘中下载：&nbsp;&nbsp;https://pan.baidu.com/s/1OjMhYgKOYW69YC2dEwFgyw&nbsp;&nbsp;提取码：ls15 安装esp8266库文件&nbsp;&nbsp;为了在Arduino的IDE中开发NodeMCU，必须在IDE中导入相关库文件，具体方法如下：打开Arduino的IDE工具栏选型-&gt;文件-&gt;首选项，进入到首选项更改界面，将库文件下载地址：http://arduino.esp8266.com/stable/package_esp8266com_index.json 填入到附加开发板管理器网址中后，选择“好”后退出首选项界面，同时重启Arduino的IDE。 &nbsp;&nbsp;重启后打开IDE工具栏选项-&gt;工具-&gt;开发板-&gt;开发板管理器,开始esp8266库文件的下载，下载时间稍长，需耐心等待。下载完成后会出现”INSTALLED”字样。同时在项目-&gt;开发板选项中会出现ESP系列开发板供选择。 使用NodeMCU进行串口通信&nbsp;&nbsp;在Arduino中新建项目文件命名为HelloNodeMcu.ino。开发板选项为NodeMCU1.0。验证代码没有语法错误后，上传代码到开发板中，上传完成后打开串口助手，将接收波特率设置为115200，此时如果串口助手接收到“HelloNode MCU”等字样，就代表esp8266库文件安装成功。 &nbsp;&nbsp;可以使用一个简单的串口通信的程序对库文件安装正确与否进行验证。 12345678910111213141516171819/*------------------------------------ written by helio, 2019 HelloNodeMcu.ino - 串口测试程序-------------------------------------*/#include "ESP8266WiFi.h"void setup()&#123; Serial.begin(115200); Serial.print("Hello NodeMCU\n"); Serial.printf("ChipId:%d\n", ESP.getChipId()); Serial.printf("CpuFreq: %d MHz\n",ESP.getCpuFreqMHz()); &#125;void loop()&#123; &#125;]]></content>
      <categories>
        <category>03 Geek</category>
        <category>NodeMCU开发</category>
      </categories>
      <tags>
        <tag>单片机开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单复数类的实现]]></title>
    <url>%2Fhelio%2F2019%2F03%2F08%2FMyComplex%2F</url>
    <content type="text"><![CDATA[使用c++语言设计一个简单的复数类MyComplex，实现复数间的基本操作，同时重载八个基本运算符运算符：+ ,- , ,/ ,+= ,-= ,= , /=,和输出运算符 &gt;&gt;，使得复数间的运算和输出变得和普通类型变量一样方便，最后使用主函数来测试类的功能是否完整。 复数类的实现类的定义complex类的定义中包含了两个私有变量real, imag, 两个构造函数，和四个重载函数以及两个非重载成员函数的定义。 12345678910111213141516class complex &#123;public: complex() = default; complex(double real, double imag) : real(real), imag(imag) &#123; &#125;; complex&amp; operator += (const complex&amp;); complex&amp; operator -= (const complex&amp;); complex&amp; operator *= (const complex&amp;); complex&amp; operator /= (const complex&amp;); complex conj(const complex&amp;); double Real() const &#123;return real;&#125; double Imag() const &#123; return imag; &#125;private: double real; double imag;&#125;; 类的私有变量类中有两个双精度浮点型私有变量, real、imag，分别代表复数的实部和虚部。123private: double real; double imag; 构造函数通过构造函数实例化某个没有初始值的复数类,重载构造函数，从而可以通过构造函数将复数的实部和虚部放入到某个实例化的复数类中。12complex() = default;complex(double real, double imag) : real(real), imag(imag) &#123;&#125; 在类中重载四种算术运算符:”+”, “-“, “*”, “/“复数的加法在复数类中对加法运算符 “+” 实现了三种重载，分别实现三种情况下的复数相加：两个纯复数相加、实数与复数相加（实数在前）、实数与复数相加（实数在后）。 1234567891011121314complex operator + (const complex &amp;x, const complex &amp;y)&#123; return complex(x.Real() + y.Real(), x.Imag() + y.Imag());&#125;complex operator + (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() + y, x.Imag());&#125;complex operator + (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() + y, x.Imag());&#125; 复数的减法同样，在复数类中对减法运算符 “-”实现了三种重载，以满足三种情况下的复数相减。123456789101112131415161718192021222324complex operator + (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() + y, x.Imag());&#125;complex operator - (const complex &amp;x, const complex &amp;y)&#123; return complex(x.Real() - y.Real(), x.Imag() - y.Imag());&#125;complex operator - (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() - y, x.Imag());&#125;complex operator - (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() - y, x.Imag());&#125;complex operator * (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() * y, x.Imag() * y);&#125; 复数的乘法在复数类中对乘法运算符 “*” 实现了三种重载，以满足三种情况下的复数相乘。1234567891011121314complex operator * (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() * y, x.Imag() * y);&#125;complex operator * (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() * y, x.Imag() * y);&#125;complex operator * (const complex &amp;x, const complex &amp;y)&#123; return complex(x.Real() * y.Real() - x.Imag() * y.Imag(), x.Real() * y.Imag() + x.Imag() * y.Real());&#125; 复数的除法同样的方法实现除法的重载。12345678910111213141516171819complex operator / (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() / y, x.Imag() / y);&#125;complex operator / (const double &amp;y, const complex &amp;x)&#123; double coef = x.Real() * x.Real() + x.Imag() * x.Imag(); complex conj = complex(x.Real(), -x.Imag()); return complex(conj.Real() / coef, conj.Imag() / coef); &#125;complex operator / (const complex &amp;x, const complex &amp;y)&#123; double coef = y.Real() * y.Real() + y.Imag() * y.Imag(); complex conj = complex(y.Real(), -y.Imag()); complex Mul = x * conj; return complex(Mul.Real() / coef, Mul.Imag() / coef);&#125; 在类中重载另外四种算术运算符:”+=”,”-=”,”*=”,”/=”由于这四种运算符会用到调用此运算符的类，属于特殊情况，所以将者四种重载函数作为复数类的成员函数。 赋值运算符”+=”的重载12345complex&amp; complex :: operator+=(const complex &amp;x)&#123; *this = *this + x; return *this; &#125; 赋值运算符”-=”的重载12345complex&amp; complex::operator-=(const complex &amp;x)&#123; *this = *this - x; return *this;&#125; 赋值运算符”*=”的重载12345complex&amp; complex :: operator*= (const complex &amp;x)&#123; *this = *this * x; return *this;&#125; 赋值运算符”/=”的重载12345complex&amp; complex :: operator/= (const complex &amp;x)&#123; *this = *this / x; return *this;&#125; 在类中重载比较运算符: “==”, “!=”为了对两个复数进行比较或者复数和实数间进行比较，所以重载这两个运算符。1234567891011121314151617181920212223242526272829bool operator == (const complex &amp;x, const complex &amp;y)&#123; return x.Real() == y.Real() &amp;&amp; y.Imag() == y.Imag();&#125;bool operator == (const complex &amp;x, const double &amp;y)&#123; return x.Real() == y &amp;&amp; x.Imag() == 0;&#125;bool operator == (const double &amp;y, const complex &amp;x)&#123; return x.Real() == y &amp;&amp; x.Imag() == 0;&#125;bool operator != (const complex &amp;x, const complex &amp;y)&#123; return x.Real() != y.Real() || x.Imag() != x.Imag();&#125; bool operator != (const complex&amp; x, double y)&#123; return x.Real() != y || x.Imag() != 0;&#125; bool operator != (double x, const complex&amp; y)&#123; return x != y.Real() || y.Imag() != 0;&#125; 输出运算符 “&lt;&lt;” 的重载为了使得复数的输出变得更加方便，可以在类的外部重载输出运算符。如当复数为 1 + 2i时，直接使用输出运算符在控制台中输出这个复数。123456std::ostream &amp;operator (std::ostream &amp;os, const complex &amp;x)&#123; os &lt;&lt; x.Real() &lt;&lt; (x.Imag() &gt; 0 ? "+" : "") &lt;&lt; x.Imag() &lt;&lt; "i"; return os;&#125; 类的测试使用测试代码对复数类的函数进行测试。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include "MyComplex.h"using namespace std;int main()&#123; complex c1(2, 3); complex c2(-2, -3); complex c3(2, 3); double y = 2.0; // 测试 "&lt;&lt;" 运算符 cout &lt;&lt; "c1= " &lt;&lt; c1 &lt;&lt; endl; cout &lt;&lt; "c2= " &lt;&lt; c2 &lt;&lt; endl; cout &lt;&lt; "c3= " &lt;&lt; c3 &lt;&lt; endl; cout &lt;&lt; endl; // 测试 “!=”, "==" 运算符 cout &lt;&lt; ((c1 == c3) ? "c1 == c3" : "c1 != c3") &lt;&lt; endl; cout &lt;&lt; ((c1 != c2) ? "c1 != c2" : "c1 == c2") &lt;&lt; endl; cout &lt;&lt; endl; // 测试 "+", "-", "*", "/" 运算符 cout &lt;&lt; "c1+c2=" &lt;&lt; c1 + c2 &lt;&lt; ", " &lt;&lt; "c1+y=" &lt;&lt; c1 + y &lt;&lt; ", " &lt;&lt; "y+c2=" &lt;&lt; y + c2 &lt;&lt; endl; cout &lt;&lt; "c1-c2=" &lt;&lt; c1 - c2 &lt;&lt; ", " &lt;&lt; "c2-y=" &lt;&lt; c2 - y &lt;&lt; ", " &lt;&lt; "y-c2=" &lt;&lt; y - c2 &lt;&lt; endl; cout &lt;&lt; "c1*c2=" &lt;&lt; c1 * c2 &lt;&lt; ", " &lt;&lt; "c1*y=" &lt;&lt; c1 * y &lt;&lt; ", " &lt;&lt; "y*c1=" &lt;&lt; y * c1 &lt;&lt; endl; cout &lt;&lt; "c1/c2=" &lt;&lt; c1 / c2 &lt;&lt; ", " &lt;&lt; "c1/y=" &lt;&lt; c1 / y &lt;&lt; ", " &lt;&lt; "y/c1=" &lt;&lt; y * c1 &lt;&lt; endl; cout &lt;&lt; endl; // 测试 “+=”, "-=", "*=", "/=" 运算符 cout &lt;&lt; "c1 += c2 =" &lt;&lt; (c1 += c2) &lt;&lt; endl; cout &lt;&lt; "c1 -= c2 =" &lt;&lt; (c1 -= c2) &lt;&lt; endl; cout &lt;&lt; "c1 *= c2 =" &lt;&lt; (c1 *= c2) &lt;&lt; endl; cout &lt;&lt; "c1 /= c2 =" &lt;&lt; (c1 /= c2) &lt;&lt; endl; getchar(); return 0;&#125; MyComplex.h源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160/*-------------------------------------------- written by helio, 2019 MyComplex.h - a simple complex class--------------------------------------------*/#ifndef _MY_COMPLEX_H#define _MY_COMPLEX_Hclass complex &#123;public: complex() = default; complex(double real = 0, double imag = 0) : real(real), imag(imag) &#123; &#125;; complex&amp; operator += (const complex&amp;); complex&amp; operator -= (const complex&amp;); complex&amp; operator *= (const complex&amp;); complex&amp; operator /= (const complex&amp;); double Real() const &#123;return real;&#125; double Imag() const &#123; return imag; &#125;private: double real; double imag;&#125;; complex operator + (const complex &amp;x, const complex &amp;y)&#123; return complex(x.Real() + y.Real(), x.Imag() + y.Imag());&#125;complex operator + (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() + y, x.Imag());&#125;complex operator + (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() + y, x.Imag());&#125;complex operator - (const complex &amp;x, const complex &amp;y)&#123; return complex(x.Real() - y.Real(), x.Imag() - y.Imag());&#125;complex operator - (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() - y, x.Imag());&#125;complex operator - (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() - y, x.Imag());&#125;complex operator * (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() * y, x.Imag() * y);&#125;complex operator * (const double &amp;y, const complex &amp;x)&#123; return complex(x.Real() * y, x.Imag() * y);&#125;complex operator * (const complex &amp;x, const complex &amp;y)&#123; return complex(x.Real() * y.Real() - x.Imag() * y.Imag(), x.Real() * y.Imag() + x.Imag() * y.Real());&#125;complex operator / (const complex &amp;x, const double &amp;y)&#123; return complex(x.Real() / y, x.Imag() / y);&#125;complex operator / (const double &amp;y, const complex &amp;x)&#123; double coef = x.Real() * x.Real() + x.Imag() * x.Imag(); complex conj = complex(x.Real(), -x.Imag()); return complex(conj.Real() / coef, conj.Imag() / coef); &#125;complex operator / (const complex &amp;x, const complex &amp;y)&#123; double coef = y.Real() * y.Real() + y.Imag() * y.Imag(); complex conj = complex(y.Real(), -y.Imag()); complex Mul = x * conj; return complex(Mul.Real() / coef, Mul.Imag() / coef);&#125;complex&amp; complex :: operator+=(const complex &amp;x)&#123; *this = *this + x; return *this; &#125;complex&amp; complex::operator-=(const complex &amp;x)&#123; *this = *this - x; return *this;&#125;complex&amp; complex :: operator*= (const complex &amp;x)&#123; *this = *this * x; return *this;&#125;complex&amp; complex :: operator/= (const complex &amp;x)&#123; *this = *this / x; return *this;&#125;complex operator + (const complex &amp;x)&#123; return x;&#125;complex operator - (const complex &amp;x)&#123; return complex(-x.Real(), -x.Imag());&#125;bool operator == (const complex &amp;x, const complex &amp;y)&#123; return x.Real() == y.Real() &amp;&amp; y.Imag() == y.Imag();&#125;bool operator == (const complex &amp;x, const double &amp;y)&#123; return x.Real() == y &amp;&amp; x.Imag() == 0;&#125;bool operator == (const double &amp;y, const complex &amp;x)&#123; return x.Real() == y &amp;&amp; x.Imag() == 0;&#125;bool operator != (const complex &amp;x, const complex &amp;y)&#123; return x.Real() != y.Real() || x.Imag() != x.Imag();&#125; bool operator != (const complex&amp; x, double y)&#123; return x.Real() != y || x.Imag() != 0;&#125; bool operator != (double x, const complex&amp; y)&#123; return x != y.Real() || y.Imag() != 0;&#125;std::ostream &amp;operator &lt;&lt; (std::ostream &amp;os, const complex &amp;x)&#123; os &lt;&lt; x.Real() &lt;&lt; (x.Imag() &gt;= 0 ? "+" : "") &lt;&lt; x.Imag() &lt;&lt; "i"; return os;&#125;#endif]]></content>
      <categories>
        <category>01 C++基础</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Good Bye,2018！]]></title>
    <url>%2Fhelio%2F2018%2F12%2F31%2FNewYear%2F</url>
    <content type="text"><![CDATA[你好，2019！ &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;望江南·超然台作&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;宋·苏轼&emsp;&emsp;春未老，风细柳斜斜。试上超然台上望，半壕春水一城花。烟雨暗千家.&emsp;&emsp;寒食后，酒醒却咨嗟。休对故人思故国，且将新火试新茶。诗酒趁年华。 var ap = new APlayer({ element: document.getElementById("aplayer-VdDWAKBh"), narrow: false, autoplay: true, showlrc: false, music: { title: "空帆船", author: "朴树", url: "http://lc-kcj3piop.cn-n1.lcfile.com/b505ba979c2c7d99106b.mp3", pic: "http://lc-kcj3piop.cn-n1.lcfile.com/5d474b1d82c4177f1b6e.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 我做了啥1~6月份 上课。&emsp;&emsp;7月份 第一次参加电赛，为了完成电赛题目，和同学老师在实验室里熬了四天三夜。&emsp;&emsp;9月份 参加全国大学生建模比赛，三个人一起在305实验室花了三天三夜的时间，终于完成了比赛论文并顺利提交。&emsp;&emsp;10月份 游西安。&emsp;&emsp;12月份 参加电赛颁奖典礼。 GET到的新技能&emsp;C++&emsp;开学没过多久就加入了kwtool项目组，第一次接触C++语言和使用VisualC++开发Windows程序，慢慢的认识到从事Windows开发需要学习哪些东西，学会了怎样使用Winsows API进行Windows程序的编写。 &emsp;数据结构&emsp;通过完成数据结构的实验(多项式的表示，赫夫曼树编码，迷宫问题，平衡二叉树的插入与删除)和观看MOOC上面的视频加上自己动手实现算法，已经对数据结构有初步的认识并可以实现一些问题的求解。 &emsp;Verilog&emsp;自己动手完成了一个简易的数字钟（显示和调整时间加上闹钟功能），对Verilog语法有了基本上的认识已经不太困难的写Verilog代码。 &emsp;个人博客&emsp;花了两个星期的周末的时间，根据网上的各种帖子，将自己的个人博客搭建起来了。 经验总结 不经一事，不长一智。 —曹雪芹 &emsp;如何成为一名优秀的Windows开发程序员&emsp;下面这张图是根据博客园博主厚积薄发的图改编而成的.&emsp;个人认为归纳的特别好，要成为一名优秀的Windows程序员，或者说程序员，我觉得这些知识都是必不可少的，未来的学习方向也会根据这个规划啦。 未来可期&emsp;#2019#&emsp;2019年想做的事情就默默埋在心里好啦！]]></content>
      <categories>
        <category>02 随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[你好，之华]]></title>
    <url>%2Fhelio%2F2018%2F11%2F17%2F%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B9%8B%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[你好，之华：&emsp;也许你已经不记得我了吧，我就是坐在你后面的那个腼腆、内向、不爱说话的那个男生。 &emsp;当别人都在谈论你的姐姐如何优秀的时候。我的眼里却只有你，我喜欢在你身后偷偷的看你和别人疯闹、看你和别人说话，为你着迷。你还记得那个时候你的橡皮为什么老是在我这里找到吗？其实我撒谎了，你的橡皮并没有掉在地上去，也不是每次那么巧都被我捡到。而是每次我趁你不注意的时候，偷偷的把你的橡皮拿过来，我只是想在你每次回头找橡皮的时候和你说上两句话啊!&emsp;那天早上我们班来了一个北京的孩子，他叫尹川，虽然是新来到我们班，但是他看起来没有丝毫的害羞与腼腆…..。从那以后我发现你的注意力完全被他吸引去了，你会去看他踢足球比赛，并且在看台上哈哈大笑，那种开心是我从来没有看到过的。你会在放学的路上和他以前踢足球，你还会去他家找他玩……。有天下午，我看你哭着从他家跑了出来，他和他妹妹站在门口望着你，我不知道发生什么了，但我当时是和你一样特别难过，但我并没有去追上你，安慰你……。从那以后，我发现你没有以前那么开心了，你也不常和别人打闹了，你经常坐在椅子上发呆，有时你会出去一会，然后回来时，眼镜是通红的。你也没有像以前那样关注尹川了。但是我还是像以前一样在你身后偷偷的看你。&emsp;我现在也有了我的爱人和家。我写这封信是想告诉你，曾经有那么一个人喜欢你，为你着迷。&emsp;&emsp;&emsp;勿念&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;小宇]]></content>
      <categories>
        <category>02 随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[游仙岛湖]]></title>
    <url>%2Fhelio%2F2018%2F10%2F28%2F%E6%B8%B8%E4%BB%99%E5%B2%9B%E6%B9%96%2F</url>
    <content type="text"><![CDATA[启程&emsp;随着汽车在山间来回辗转，我们在车上睡了又醒，十一点左右终于到达了目的地——一个被群山包围着的小县城。沿街最多的就是卖水产的商店和挂着“住宿”招牌的房子，显然这是一个依靠旅游才发展起来的位置.因为是淡季，所以并没有感到很拥挤，街上的车也不是很多，顺着坡下去，从入口进去我们就到了码头。登船&emsp;在码头船上等了十几分钟后，它就载着我们往湖中去了，站在船尾，湖面上的暖风迎面而来，船尾是因发动机运转而激起的水花，放眼望去，有蓝色的湖水和环绕着湖水的远山，顿时觉得心旷神怡。&emsp;如果此时你问我是喜欢水还是喜欢山，那我一定会肯定的回答：水。 尽兴而归&emsp;我们分别在两座小岛上转了一圈后，已经快下午五点了，已而夕阳在山，人影散乱，我们也匆匆忙忙的往返程的游船上赶。人在囧途&emsp;当我们从船上下来准备返程是，我们发现一个严重的问题，返回阳新城的班车早已发完，我们在小县城的街道上游荡了好久才找到返回的车辆，当然是价格没有商量的那种。]]></content>
      <categories>
        <category>02 随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2Fhelio%2F2018%2F10%2F24%2Fhello%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Welcome to Helio Blog&emsp;&emsp;永远相信美好的事情即将发生！]]></content>
      <categories>
        <category>02 随笔</category>
      </categories>
  </entry>
</search>
